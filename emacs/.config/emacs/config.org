#+title: Dante's GNU Emacs Config
#+author: Dante Yasui
#+startup: 2
#+options: toc

* TABLE OF CONTENTS :TOC:
- [[#package-management][Package Management]]
  - [[#elpaca-package-manager][Elpaca Package Manager]]
  - [[#evil-mode-collection][Evil Mode Collection]]
- [[#core-behavior][Core Behavior]]
  - [[#essential-settings][Essential Settings]]
  - [[#temporary-files-location][Temporary Files Location]]
  - [[#window-and-buffer-management][Window and Buffer Management]]
- [[#appearance][Appearance]]
  - [[#color-themes][Color Themes]]
  - [[#font-configuration][Font Configuration]]
  - [[#dashboard][Dashboard]]
  - [[#rainbow-mode-display-hex-colors-in-buffers][Rainbow Mode: display HEX colors in buffers]]
  - [[#olivetti-mode-zen-mode][Olivetti-mode (Zen mode)]]
- [[#editor-enhancements][Editor Enhancements]]
  - [[#completion-framework][Completion Framework]]
  - [[#projectworkspace-management][Project/Workspace Management]]
  - [[#terminal-emulation][Terminal Emulation]]
  - [[#command-discovery][Command Discovery]]
  - [[#file-viewing][File Viewing]]
- [[#keybindings][Keybindings]]
  - [[#general-keybindings][General Keybindings]]
  - [[#zooming-inout][Zooming In/Out]]
- [[#org-mode][Org Mode]]
  - [[#core-configuration][Core Configuration]]
  - [[#appearance-1][Appearance]]
  - [[#citation-management][Citation Management]]
- [[#ai-integration][AI Integration]]
  - [[#gptel-configuration][=gptel= Configuration]]
  - [[#assistant-functions][Assistant functions]]
- [[#technical-workflows][Technical Workflows]]
  - [[#emacs-speaks-statics-ess---r-and-julia-code-integration][Emacs Speaks Statics (ESS) - R and julia code integration]]
  - [[#latex][LaTeX]]
  - [[#pdf-tools][PDF-Tools]]
- [[#added-by-llm-assistant][Added by LLM Assistant]]
- [[#llm-integration-1][LLM Integration]]
  - [[#new-tool-read-org-heading][New Tool: Read Org Heading]]

* Package Management
  Some things (like package manager) need to load first in emacs startup.
  So we'll start with them.
** Elpaca Package Manager
#+begin_src emacs-lisp
(defvar elpaca-installer-version 0.11)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
         :ref nil :depth 1 :inherit ignore
         :files (:defaults "elpaca-test.el" (:exclude "extensions"))
         :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (< emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
 (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
    ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
        ,@(when-let* ((depth (plist-get order :depth)))
            (list (format "--depth=%d" depth) "--no-single-branch"))
        ,(plist-get order :repo) ,repo))))
    ((zerop (call-process "git" nil buffer t "checkout"
     (or (plist-get order :ref) "--"))))
    (emacs (concat invocation-directory invocation-name))
    ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
     "--eval" "(byte-recompile-directory \".\" 0 'force)")))
    ((require 'elpaca))
    ((elpaca-generate-autoloads "elpaca" repo)))
     (progn (message "%s" (buffer-string)) (kill-buffer buffer))
   (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (load "./elpaca-autoloads")))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))
;; (elpaca example-package)
;; Install use-package support
(elpaca elpaca-use-package
  ;; Enable :elpaca use-package keyword.
  (elpaca-use-package-mode)
  ;; Assume :elpaca t unless otherwise specified.
  (setq elpaca-use-package-by-default t))

;; Block until current queue processed.
(elpaca-wait)

;;When installing a package which modifies a form used at the top-level
;;(e.g. a package which adds a use-package key word),
;;use `elpaca-wait' to block until that package has been installed/configured.
;;For example:
;;(use-package general :demand t)
;;(elpaca-wait)

;;Turns off elpaca-use-package-mode current declartion
;;Note this will cause the declaration to be interpreted immediately (not deferred).
;;Useful for configuring built-in emacs features.
;;(use-package emacs :elpaca nil :config (setq ring-bell-function #'ignore))

;; Don't install anything. Defer execution of BODY
;;(elpaca nil (message "deferred"))

(provide 'elpaca-setup)

;;; elpaca-setup.el ends here

#+end_src

** Evil Mode Collection
Evil-mode adds vim bindings to text editing buffers when =evil-mode= is active.
To get the vim bindings to work in other types of buffers
(like dired and ibuffer), we also need the =evil-collection=.
#+begin_src emacs-lisp
;; Expands to: (elpaca evil (use-package evil :demand t))
(use-package evil
    :init      ;; tweak evil's configuration before loading it
    (setq evil-want-integration t  ;; This is optional since it's already set to t by default.
          evil-want-keybinding nil
          evil-vsplit-window-right t
          evil-split-window-below t
       evil-want-C-u-scroll t ;; override emacs-like use of C-u to repeat
          evil-undo-system 'undo-redo)  ;; Adds vim-like C-r redo functionality
    (evil-mode))

(use-package evil-collection
  :after evil
  :config
  ;; Do not uncomment this unless you want to specify each and every mode
  ;; that evil-collection should works with.  The following line is here 
  ;; for documentation purposes in case you need it.  
  ;; (setq evil-collection-mode-list '(calendar dashboard dired ediff info magit ibuffer))
  (add-to-list 'evil-collection-mode-list 'help) ;; evilify help mode
  (evil-collection-init))

;; Using RETURN to follow links in Org/Evil 
;; Unmap keys in 'evil-maps if not done, (setq org-return-follows-link t) will not work
(with-eval-after-load 'evil-maps
  (define-key evil-motion-state-map (kbd "SPC") nil)
  (define-key evil-motion-state-map (kbd "RET") nil)
  (define-key evil-motion-state-map (kbd "TAB") nil))
;; Setting RETURN key in org-mode to follow links
  (setq org-return-follows-link  t)
#+end_src

* Core Behavior
** Essential Settings
#+begin_src emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(setq ring-bell-function 'ignore)
(setq tab-bar-close-button-show nil)       ;; hide tab close / X button
(setq tab-bar-new-tab-choice "*dashboard*");; buffer to show in new tabs
(setq-default indent-tabs-mode nil) ;; use spaces instead of tabs
;; (global-display-line-numbers-mode nil)
(global-visual-line-mode t)
#+end_src

** Temporary Files Location
By default, tilde and other temporary files generated by emacs seem to clutter my normal workspaces.
This option should keep them in a subdirectory of the emacs =user-directory=.
#+begin_src emacs-lisp
;; save temp files to ~/.config/emacs/auto-save
;; (setq auto-save-file-name-transforms
          ;; `((".*" ,(concat user-emacs-directory "auto-save/") t))) 
(setq backup-directory-alist '((".*" . "~/.local/share/Trash/files")))
#+end_src

** Window and Buffer Management
Taken from the EmacsWiki: https://www.emacswiki.org/emacs/buffer-move.el
#+begin_src emacs-lisp
(require 'windmove)

;;;###autoload
(defun buf-move-up ()
  "Swap the current buffer and the buffer above the split.
If there is no split, ie now window above the current one, an
error is signaled."
;;  "Switches between the current buffer, and the buffer above the
;;  split, if possible."
  (interactive)
  (let* ((other-win (windmove-find-other-window 'up))
  (buf-this-buf (window-buffer (selected-window))))
    (if (null other-win)
        (error "No window above this one")
      ;; swap top with this one
      (set-window-buffer (selected-window) (window-buffer other-win))
      ;; move this one to top
      (set-window-buffer other-win buf-this-buf)
      (select-window other-win))))

;;;###autoload
(defun buf-move-down ()
"Swap the current buffer and the buffer under the split.
If there is no split, ie now window under the current one, an
error is signaled."
  (interactive)
  (let* ((other-win (windmove-find-other-window 'down))
  (buf-this-buf (window-buffer (selected-window))))
    (if (or (null other-win) 
            (string-match "^ \\*Minibuf" (buffer-name (window-buffer other-win))))
        (error "No window under this one")
      ;; swap top with this one
      (set-window-buffer (selected-window) (window-buffer other-win))
      ;; move this one to top
      (set-window-buffer other-win buf-this-buf)
      (select-window other-win))))

;;;###autoload
(defun buf-move-left ()
"Swap the current buffer and the buffer on the left of the split.
If there is no split, ie now window on the left of the current
one, an error is signaled."
  (interactive)
  (let* ((other-win (windmove-find-other-window 'left))
  (buf-this-buf (window-buffer (selected-window))))
    (if (null other-win)
        (error "No left split")
      ;; swap top with this one
      (set-window-buffer (selected-window) (window-buffer other-win))
      ;; move this one to top
      (set-window-buffer other-win buf-this-buf)
      (select-window other-win))))

;;;###autoload
(defun buf-move-right ()
"Swap the current buffer and the buffer on the right of the split.
If there is no split, ie now window on the right of the current
one, an error is signaled."
  (interactive)
  (let* ((other-win (windmove-find-other-window 'right))
  (buf-this-buf (window-buffer (selected-window))))
    (if (null other-win)
        (error "No right split")
      ;; swap top with this one
      (set-window-buffer (selected-window) (window-buffer other-win))
      ;; move this one to top
      (set-window-buffer other-win buf-this-buf)
      (select-window other-win))))
#+end_src
* Appearance
** Color Themes

Point to location of custom color theme files.
#+begin_src emacs-lisp
(add-to-list 'custom-theme-load-path "~/.config/emacs/themes/")
(load-theme 'kanagawa t)
#+end_src

Also load additional themes from the DOOM distribution.
#+begin_src emacs-lisp
  (use-package doom-themes
    :ensure t
    :config
    ;; (load-theme 'doom-one t)
    (setq doom-themes-enable-bold t
   doom-themes-enable-italic t)
    (doom-themes-org-config))
  ;; solaire darkens non-standard buffers' backgrounds
  ;; (use-package solaire-mode
  ;;   :ensure t
  ;;   :config
  ;;   (solaire-global-mode +1))
  ;; ;; doom's fancy modeline
  (use-package doom-modeline
    :ensure t
    :init (doom-modeline-mode 1)
    :config
    (setq doom-modeline-env-enable-python t)
    (setq doom-modeline-env-enable-R t)
    (setq doom-modeline-env-enable-julia t)
    (setq doom-modeline-height 18))
#+end_src
** Font Configuration
Emacs uses various fonts and font styles in different places. =ttt=
*** Setting the font face
#+begin_src emacs-lisp
(set-face-attribute 'default nil
       :font "Liga SFMono Nerd Font"
       ;; height = 10*point size
       :height 160
       :weight 'medium)
(set-face-attribute 'variable-pitch nil
       :font "CMU Serif"
       :height 1.0
       :weight 'medium)
(set-face-attribute 'fixed-pitch nil
       :font "Liga SFMono Nerd Font"
       :height 0.6
       :weight 'medium)
  ;; italicizes commented text and keywords
  (set-face-attribute 'font-lock-comment-face nil
        :slant 'italic)
  (set-face-attribute 'font-lock-keyword-face nil
        :slant 'italic)
  ;;sets default font on all graphical frames after restarting emacs
  ;; (add-to-list 'default-frame-alist '(font . "JetBrainsMono Nerd Font-10"))

  ;;set default line spacing
  ;; (setq-default line-spacing 0.08)

#+end_src

** Dashboard
Extensible dashboard to show recent files, bookmarks, agenda items, etc on startup
#+begin_src emacs-lisp
(use-package dashboard
  :ensure t
  :init
  (setq initial-buffer-choice 'dashboard-open)
  (setq dashboard-set-heading-icons t)
  (setq dashboard-set-file-icons t)
  (setq dashboard-banner-logo-title "Welcome to Emacs")
  (setq dashboard-startup-banner 'logo)
  (setq dashboard-center-content t)
  (setq dashboard-items '((recents . 5)
                        (projects . 5)
                        (bookmarks . 3)
                        (agenda . 3)
                        (registers . 3)))
  ;; (dashboard-modify-heading-icons '((recents . "file-text")
  ;;                                  (bookmarks . "book")))
  :config
  (dashboard-setup-startup-hook))
#+end_src
** Rainbow Mode: display HEX colors in buffers
Display the actual color as a background for any hex color value (ex. #ffffff).
This code enables rainbow-mode in all programming nodes as well as org-mode.
#+begin_src emacs-lisp
(use-package rainbow-mode
  :ensure t
  :hook (org-mode prog-mode))
#+end_src

** Olivetti-mode (Zen mode)
Installed from melpa-stable
#+begin_src emacs-lisp
(use-package olivetti
  :ensure t
  :hook (org-mode)
  :config
  (setq olivetti-body-width 100))
#+end_src

* Editor Enhancements
** Completion Framework
*** Complete Anything
[[https://company-mode.github.io/manual/][Company manual]]
Text completion framework to "/complete anything/" in Emacs.
Completion starts after typing a few letters in any text buffer. Use M-n and M-p to select, <return> to complete, or <tab> to complete the common part.
=company-box= makes the completion window look nicer.
#+begin_src emacs-lisp
(use-package company
  :defer 2
  :custom
  (company-begin-commands '(self-insert-command))
  (company-idle-delay .1)
  (company-minimum-prefix-length 2)
  (company-show-numbers t)
  (company-tooltip-align-annotations 't)
  (global-company-mode t))
(set (make-local-variable 'company-backends) '((company-yasnippet company-capf company-keywords)))

(use-package company-box
  :after company
  :hook (company-mode . company-box-mode))

;; Ido modes
(fido-vertical-mode t)
;; (icomplete-vertical-mode t)
#+end_src

I had to change the =use-package= call on =company= to happen after setting the =company-backends= values to avoide the error:
#+begin_example
Symbol's value as variable is void: company-backends
#+end_example

*** Snippet Management
#+begin_src emacs-lisp
(use-package yasnippet
  :ensure t
  :config
  (setq yas-snippet-dirs '("~/.config/emacs/snippets"))
  (yas-global-mode 1))
#+end_src

Taken from a random [[https://www.reddit.com/r/emacs/comments/3r9fic/best_practicestip_for_companymode_andor_yasnippet/][reddit thread]]:
#+begin_src emacs-lisp
;; weight by frequency
(setq company-transformers '(company-sort-by-occurrence))

;; Add yasnippet support for all company backends
;; https://github.com/syl20bnr/spacemacs/pull/179
(defvar company-mode/enable-yas t "Enable yasnippet for all backends.")

(defun company-mode/backend-with-yas (backend)
  (if (or (not company-mode/enable-yas) (and (listp backend)    (member 'company-yasnippet backend)))
  backend
(append (if (consp backend) backend (list backend))
        '(:with company-yasnippet))))

(setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
#+end_src

** Project/Workspace Management
I want to group buffers into different workspaces, which is something handled by the package =perspective=.
#+begin_src emacs-lisp
(use-package perspective
  :init
  (persp-mode)
  :custom
  (persp-mode-prefix-key (kbd "C-x p"))
  :config
  (setq switch-to-prev-buffer-skip
      (lambda (win buff bury-or-kill)
        (not (persp-is-current-buffer buff)))))
#+end_src

Projectile project interaction library.
#+begin_src emacs-lisp
(use-package projectile
  :disabled
  :config
  (projectile-mode 1))
#+end_src

I thought I was using =projectile= to keep track of my vc projects, but now it looks like I mostly just use =project-find-file= which is part of the native package =project.el=.

Use =recentf-open-files= to see a list of recently opened files
#+begin_src emacs-lisp
(require 'recentf)
(recentf-mode 1)
(setq recentf-max-menu-items 25)
#+end_src
** Terminal Emulation
#+begin_src emacs-lisp
(use-package vterm
  :ensure t)
#+end_src
#+begin_src emacs-lisp
(use-package vterm-toggle
  :ensure t
  :after vterm
  :config
  (setq vterm-toggle-fullscreen-p nil)
  (setq vterm-toggle-scope 'project)
  (add-to-list 'display-buffer-alist
     '((lambda (buffer-or-name _)
     (let ((buffer (get-buffer buffer-or-name)))
 (with-current-buffer buffer
   (or (equal major-mode 'vterm-mode)
       (string-prefix-p vterm-buffer-name (buffer-name buffer))))))
  (display-buffer-reuse-window display-buffer-at-bottom)
  ;;(display-buffer-reuse-window display-buffer-in-direction)
  ;;display-buffer-in-direction/direction/dedicated is added in emacs27
  ;;(direction . bottom)
  ;;(dedicated . t) ;dedicated is supported in emacs27
  (reusable-frames . visible)
  (window-height . 0.3)))
  )
#+end_src

** Command Discovery
#+begin_src emacs-lisp
(use-package which-key
  :init
  (which-key-mode 1)
  :config
  (setq which-key-side-window-location 'bottom
 which-key-sort-order #'which-key-key-order-alpha
 which-key-sort-uppercase-first nil
 which-key-add-column-padding 1
 which-key-max-display-columns nil
 which-key-min-display-lines 6
 which-key-side-window-slot -10
 which-key-side-window-max-height 0.25
 which-key-idle-delay 0.8
 which-key-max-description-length 25
 which-key-allow-imprecise-window-fit nil
 which-key-separator " ÔÅ° " ))
#+end_src

** File Viewing
#+begin_src emacs-lisp
(use-package dired-open
  :config
  (setq dired-open-extensions '(("gif" . "sxiv")
    ("jpg" . "sxiv")
    ("png" . "sxiv")
    ("mkv" . "mpv")
    ("mp4" . "mpv"))))
    
#+end_src

* Keybindings
** General Keybindings
#+begin_src emacs-lisp
(use-package general
  :ensure t
  :config
  (general-evil-setup)
  
  (general-define-key
   :states '(normal visual)
   :keymaps 'override
   "g c c" '(comment-line :wk "Comment Line"))
  
  ;; set space bar as global leader key
  (general-create-definer dy/leader-keys
    :states '(normal insert visual emacs)
    :keymaps 'override
    :prefix "SPC" ;; set leader
    :global-prefix "C-SPC") ;; access leader in insert mode
  
  (general-define-key
   :keymaps 'override
   "M-n" '(make-frame :wk "Open new frame")
   "M-w" '(delete-frame :wk "Close current frame")
   "M-." '(dired :wk "Dired"))
  
  (dy/leader-keys
    "SPC" '(execute-extended-command :wk "M-x")
    "c s" '(cheat-sheet :wk "Cheat Sheet"))
  
  (dy/leader-keys
    "f f" '(find-file :wk "Find file")
    "f c" '((lambda () (interactive) (find-file "~/.config/emacs/config.org")) :wk "Edit emacs config")
    "f i" '(imenu :wk "Find index")
    "f r" '(recentf :wk "Find recent files")
    "f s" '(affe-grep :wk "Find string in current project"))
  
  (dy/leader-keys
    "b" '(:ignore t :wk "buffer")
    "b q" '(kill-this-buffer :wk "Kill buffer")
    "b n" '(next-buffer :wk "Next buffer")
    "b p" '(previous-buffer :wk "Previous buffer")
    "b r" '(revert-buffer :wk "Reload buffer")
    "b s" '(switch-to-buffer :wk "Switch buffers")
    "b S" '(persp-switch-to-buffer :wk "Switch buffers (from any perspective")
    "b i" '(ibuffer :wk "Buffer Index"))
  
  (dy/leader-keys
    "c" '(:ignore t :wk "comment")
    ;; "c c" '(comment-line :wk "comment line")
    "c r" '(comment-region :wk "comment region")
    "c b" '(comment-box :wk "comment box"))
  
  (dy/leader-keys
    "d" '(:ignore t :wk "dired")
    "d d" '(dired :wk "open dired")
    "d j" '(dired-jump :wk "open current directory")
    "d L" '(dired-jump-other-window :wk "open current directory in new window"))
  
  (dy/leader-keys
    "e" '(:ignore t :wk "Eshell/Evaluate")
    "e b" '(eval-buffer :wk "Evaluate elisp in buffer")
    "e d" '(eval-defun :wk "Evaluate defun containing or after point")
    "e e" '(eval-expression :wk "Evaluate an elisp expression")
    "e l" '(eval-last-sexp :wk "Evaluate elisp expression before point")
    "e r" '(eval-region :wk "Evaluate elisp in region")
    "e s" '(eshell :wk "Eshell"))
  
  (dy/leader-keys
    "h" '(:ignore t :wk "Help")
    "h f" '(describe-function :wk "Describe function")
    "h k" '(describe-key :wk "Describe keybinding")
    "h v " '(describe-variable :wk "Describe variable")
    "h r r" '((lambda () (interactive) (load-file "~/.config/emacs/init.el")) :wk "Reload emacs config"))
  
  (dy/leader-keys
    "m" '(:ignore t :wk "Bookmark")
    "m s" '(bookmark-set :wk "Set a bookmark")
    "m j" '(bookmark-jump :wk "Jump to a bookmark")
    "m t t" '(org-todo :wk "Mark as TODO")
    "m l" '(list-bookmarks :wk "List bookmarks"))
  
  (dy/leader-keys
    "o" '(:ignore t :wk "Org")
    "o a" '(org-agenda :wk "Org agenda")
    "o e" '(org-export-dispatch :wk "Org export dispatch")
    "o i" '(org-toggle-item :wk "Org toggle item")
    "o t" '(org-todo :wk "Org todo")
    "o b t" '(org-babel-tangle :wk "Org babel tangle")
    "o T" '(org-todo-list :wk "Org todo list"))
  
  (dy/leader-keys
    "o d" '(:ignore t :wk "Dates/times")
    "o d t" '(org-time-stamp :wk "Org time stamp"))
  
  (dy/leader-keys
    "p" '(:ignore :wk "Project")
    "p f" '(project-find-file :wk "Find files in current project")
    "p d" '(project-dired :wk "Open dired for project directory")
    "p s" '(persp-switch :wk "Switch Perspectives")
    "p o" '(project-switch-project :wk "Switch or open project")
    "p b" '(project-list-buffers :wk "List project buffers")
    "p k" '(project-kill-buffers :wk "Close all project buffers")
    )
  
  (dy/leader-keys
    "r" '(:ignore :wk "R")
    "r d" '(ess-rdired  :wk "open R object directory"))
  
  (dy/leader-keys
    "s" '(:ignore :wk "snippets")
    "s n" '(yas-new-snippet :wk "new snippet"))
  
  (dy/leader-keys
    "t" '(:ignore t :wk "Toggle")
    "t b" '(org-hide-block-all :wk "Toggle org blocks")
    "t c" '(quick-calc :wk "Toggle calculator")
    "t i" '(org-toggle-inline-images :wk "Toggle inline images")
    "t l" '(display-line-numbers-mode :wk "Toggle line numbers")
    "t t" '(visual-line-mode :wk "Toggle truncated lines")
    "t v" '(vterm-toggle :wk "Toggle vterm")
    "t m p" '(mixed-pitch-mode :wk "Toggle mixed-pitch mode")
    "t z" '(olivetti-mode :wk "Toggle olivetti (zen) mode"))
  
  (dy/leader-keys
    "v" '(:ignore t :wk "Version Control")
    "v s" '(magit-status :wk "Git status")
    "v r" '(vc-region-history :wk "Version history of region"))
  
  
  (dy/leader-keys
    "w" '(:ignore t :wk "Windows")
    ;; Window splits
    "w q" '(evil-window-delete :wk "Close window")
    "w n" '(evil-window-new :wk "New window")
    "w s" '(evil-window-split :wk "Horizontal split window")
    "w v" '(evil-window-vsplit :wk "Vertical split window")
    ;; Window motions
    "w h" '(evil-window-left :wk "Window left")
    "w j" '(evil-window-down :wk "Window down")
    "w k" '(evil-window-up :wk "Window up")
    "w l" '(evil-window-right :wk "Window right")
    "w w" '(evil-window-next :wk "Goto next window")
    ;; Move Windows
    "w H" '(buf-move-left :wk "Buffer move left")
    "w J" '(buf-move-down :wk "Buffer move down")
    "w K" '(buf-move-up :wk "Buffer move up")
    "w L" '(buf-move-right :wk "Buffer move right"))
  )
#+end_src
** Zooming In/Out
#+begin_src emacs-lisp
  (global-set-key (kbd "C-=") 'text-scale-increase)
  (global-set-key (kbd "C--") 'text-scale-decrease)
  (global-set-key (kbd "<C-wheel-up>") 'text-scale-increase)
  (global-set-key (kbd "<C-wheel-down>") 'text-scale-decrease)
#+end_src
* Org Mode
** Core Configuration
#+begin_src emacs-lisp
(setq org-agenda-files (list "~/Org"))

(use-package org-journal
  :ensure t
  :defer t
  :init
  ;; Change default prefix key; needs to be set before loading org-journal
  (setq org-journal-prefix-key "<SPC> j")
  :config
  (setq org-journal-dir "~/Org/journals/")
  (setq org-journal-file-format "%Y_%m_%d.org"))

;; Language support
(org-babel-do-load-languages
 'org-babel-load-languages
 '((julia . t)
   (latex . t)
   (shell . t)
   (R . t)))

;; org-tempo is not enabled by default,
;;allows a quick way to add source blocks.
(require 'org-tempo)
#+end_src
** Appearance
*** Enabling Table of Contents
#+begin_src emacs-lisp
(use-package toc-org
:ensure t
:commands toc-org-enable
:init (add-hook 'org-mode-hook 'toc-org-enable))
#+end_src

*** Org-Modern
<<Modern>>-looking visual style for org buffer rendering.
#+begin_src emacs-lisp
(use-package org-modern
  :ensure t
  :hook org-mode
  :config
  (setq org-modern-star 'replace)
  (custom-set-variables
    '(org-modern-replace-stars "‚óâ‚óã‚ùñ‚óà‚óá"))
  (custom-set-variables
   '(org-modern-checkbox
     '((?X . #("‚ñ°‚úî" 0 2 (composition ((2)))))
      (?\s . "‚ñ°")
      (?- . #("‚ñ°‚Äì" 0 2 (composition ((2))))))))
  (custom-set-variables
   '(org-modern-list
    '((?+ . "‚Ä¢")
      (?- . "‚ó¶")
      (?* . "‚àó"))))
  (custom-set-variables
   '(org-modern-radio-target '(" ‚úí " t " ")))
  (custom-set-variables
   '(org-modern-internal-target '(" ‚Ü™ " t " ")))
  (setq org-modern-symbol '"Iosevka")
  (setq org-modern-keyword
 (quote (("title" . "üìì") (t . t)))))
    ;; (("title" . "üìì") (t . t))
    ;; (("date" . "üìÖ") (t . t))
    ;; (("author" . "üñé") (t . t))
#+end_src
**** Examples:
-----
- item <2025-08-01 Fri>
  + subitem <2025-08-01 Fri>
    * [X] Checked off
    * [ ] unchecked
    - [-] partially checked
-----
Table:
| col 1  | col 2  |
|--------+--------|
| item 1 | item 2 |
-----
***** TODO labels
****** DONE [#A] Most important
****** TODO [#B] Less important [0%]
****** CANCEL [#C] not important anymore [50%]
****** DONE [#A] Everything combined :tag:test:
- [X] first [100%]
- [X] second
- [X] third
*** Disable Electric Indent
Whenever I would add a new line inside a source block in org mode,
everything inside would automatically get indented which was really
annoying.
By default =electric-indent-mode= is turned on in Emacs, so we have to turn it off.
#+begin_src emacs-lisp
(setq electric-indent-mode -1)
(setq org-src-preserve-indentation t)
(setq org-edit-src-content-indentation 0)
#+end_src

*** Hide Emphasis Markers
#+begin_src emacs-lisp
(setq org-hide-emphasis-markers t)
#+end_src

***  Mixed-pitch in Org mode
#+begin_src emacs-lisp
(use-package mixed-pitch
  :hook
  (org-mode . mixed-pitch-mode))
#+end_src

*** Org-elipses
#+begin_src emacs-lisp
(setq org-ellipsis "‚á•")
#+end_src
*** LaTeX preview
LaTeX text like this $\beta_0 + \beta_1 X_i + \epsilon_i$ should be previewed better than by default:

$$\text{Hello, World!}^\infty \sum_i x_i = \bar{Q}$$
#+begin_src emacs-lisp
;; (use-package org-latex-preview
;;   :ensure t
;;   :config
;;   (plist-put org-latex-preview-appearance-options
;;       :page-width 0.8)
;;   (setq org-latex-preview-live t))
#+end_src
** Citation Management

#+begin_src emacs-lisp
(setq org-cite-global-bibliography '("~/betterbibtex.bib"))
#+end_src

#+begin_src emacs-lisp
;; (use-package citar
;;   :custom
;;   (citar-bibliography '("~/zotero-library.bib"))
;;   ;; Use `citar' with `org-cite'
;;   (org-cite-insert-processor 'citar)
;;   (org-cite-follow-processor 'citar)
;;   (org-cite-activate-processor 'citar)
;;   :hook
;;   (LaTeX-mode . citar-capf-setup)
;;   (org-mode . citar-capf-setup))
;;
;; (use-package citar-embark
;;   :after citar embark
;;   :no-require
;;   :config (citar-embark-mode))
;;
;; (use-package embark
;;   :ensure t)
#+end_src

* AI Integration
** =gptel= Configuration
[[https://github.com/karthink/gptel][gptel documentation]]
#+begin_src emacs-lisp
;; transient required by gptel
(use-package transient
  :ensure (:ref "v0.10.1")
  :demand t)

(use-package gptel
  ;; I was having conflicting versions with elpaca until I set this
  ;; :load-path "elpa/gptel-0.9.9/" 
  :ensure t
  :after transient
  :config
  ;; jump cursor to next prompt line
  (add-hook 'gptel-post-response-functions 'gptel-end-of-response)
   ;; setting the gptel-api-key with the host name works here
  (setq auth-sources '("~/.authinfo"))
  (setq gptel-api-key
 (auth-source-pick-first-password :host "openrouter.ai"))
  (setq gptel-default-mode 'org-mode) ;; chat in org-mode or markdown
  (setq gptel-prompt-prefix-alist
   '((org-mode . "* ÔÅµ :") (text-mode . "üí¨ :")))
  (setq gptel-response-prefix-alist
   '((org-mode . "** Ó¨à ") (text-mode . "> ü§ñ ")))
  (gptel-make-openai "LMStudio"
    :protocol "http"
    :host "localhost:1234"
    :stream t
    ;; :context t
    ;; :sources t
    :models '(qwen3-14b-mlx
              qwen3-4b-thinking-2507
              qwen3-4b-2507
              qwen3-30b-a3b
              gemma-3n-e4b
              qwen3-14b))
  (setq gptel-model   'google/gemini-2.5-flash
      gptel-backend
      (gptel-make-openai "OpenRouter"
        :host "openrouter.ai"
        :endpoint "/api/v1/chat/completions"
        :stream t
 :key gptel-api-key ; function that returns key from .authinfo
 :models '(google/gemini-2.5-pro
           google/gemini-2.5-flash
           anthropic/claude-sonnet-4.5
           openai/gpt-5
           z-ai/glm-4.6
           qwen/qwen3-vl-235b-a22b-thinking
           qwen/qwen3-vl-235b-a22b-instruct
           deepseek/deepseek-r1-0528))))
#+end_src
** Assistant functions
#+begin_src emacs-lisp
;;;; My Local AI Assistant
;;;
;;; This section contains the functions for a local AI assistant that
;;; uses gptel for the brain, and will later use local TTS/STT.

(defcustom my-assistant-backend 'Ollama
  "The `gptel-backend' to use for the assistant."
  :type '(symbol)
  :group 'gptel)

(defcustom my-assistant-model "qwen3-14b"
  "The `gptel-model' to use for the assistant."
  :type '(string)
  :group 'gptel)

(defun my-assistant-ask (prompt)
  "Send PROMPT to the assistant's LLM and return the response synchronously.
This function will block until the LLM response is received."
  (let ((response-text nil))
    ;; Call the asynchronous function with our custom callback.
    (gptel-request prompt
                   :callback (lambda (response _info)
                               ;; This runs when the answer arrives.
                               (setq response-text (or response ""))))
    ;; Wait for the callback to set the `response-text` variable.
    (while (not response-text)
      (accept-process-output nil 0.1))
    ;; Return the final result.
    response-text))
(defcustom my-assistant-piper-model "en_US-kusal-medium"
  "The Piper voice model to use for TTS."
  :type 'string
  :group 'gptel)

(defcustom my-assistant-piper-data-dir nil
  "Directory containing Piper voice models. If nil, uses current directory."
  :type '(choice (const :tag "Current directory" nil)
                 (directory :tag "Custom directory"))
  :group 'gptel)

(setq my-assistant-piper-data-dir "~/.local/share/piper-voices")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; My Assistant - Core Function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun my-assistant-speak (text)
  "Speak TEXT using Piper TTS engine with robust audio playback."
  (message "ASSISTANT (speak): Requesting TTS for \"%s...\"" (substring text 0 (min 30 (length text))))
  (unless (executable-find my-assistant-piper-executable)
    (error "Cannot find Piper executable: '%s'. Check =my-assistant-piper-executable= and Emacs =exec-path="
           my-assistant-piper-executable))
  (let* ((temp-file (make-temp-file "piper-tts-" nil ".wav"))
         (data-dir-arg (when (and my-assistant-piper-data-dir (file-directory-p my-assistant-piper-data-dir))
                         (list "--data-dir" (expand-file-name my-assistant-piper-data-dir))))
         (piper-args (append (list "-m" my-assistant-piper-model "-f" temp-file)
                             data-dir-arg
                             (list "--" text))))
    (unwind-protect
        (let* ((piper-output-buffer (generate-new-buffer "*piper-output*"))
               (exit-code (apply #'call-process my-assistant-piper-executable nil piper-output-buffer t piper-args)))
          (if (/= exit-code 0)
              (progn
                (display-buffer piper-output-buffer)
                (error "Piper process failed with exit code %s. See *piper-output* buffer." exit-code))
            (kill-buffer piper-output-buffer)
            (when (file-exists-p temp-file)
              (message "Piper generated audio: %s" temp-file)
              (if (executable-find "play")
                  (let ((play-output-buffer (generate-new-buffer "*play-output*")))
                    (message "Attempting to play audio with 'play'...")
                    (let ((play-exit-code (call-process "play" nil play-output-buffer t temp-file)))
                      (if (/= play-exit-code 0)
                          (progn
                            (display-buffer play-output-buffer)
                            (error "Sox 'play' process failed with exit code %d. See *play-output* buffer." play-exit-code))
                        (kill-buffer play-output-buffer)
                        (message "Audio playback finished."))))
                (error "Sox 'play' command not found. Cannot play audio."))))
          )
      (when (file-exists-p temp-file)
        (delete-file temp-file)))))

;; --- Phase 3 Placeholder ---
(defun my-assistant-listen ()
  "Listen for audio and return the transcribed text. (Placeholder)"
  (let ((input (read-from-minibuffer "ASSISTANT (listen): ")))
    (message "ASSISTANT (listen): You said '%s'" input)
    input))

;; --- The Main Interactive Function ---
(defun my-assistant-interactive ()
  "Ask the assistant a question and get a spoken response."
  (interactive)
  (let* ((question (read-from-minibuffer "Ask your assistant: "))
         (answer (my-assistant-ask question)))
    (my-assistant-speak answer)))

#+end_src

#+RESULTS:
: my-assistant-interactive

* Technical Workflows
** Emacs Speaks Statics (ESS) - R and julia code integration
The Emacs Speaks Statistics (ESS) package has lots of functionality for working with statistical and scientific languages in Emacs.
They seem to be heralding a switch to [[https://github.com/polymode/poly-org][polymode]], but I think org's babel function is enough for me right now.
#+begin_src emacs-lisp
(use-package ess
  :ensure t
  :config
  (load "ess-autoloads")
  (load-library "ob-R")
  (load-library "ob-julia")
  (setq org-confirm-babel-evaluate nil))
#+end_src
** LaTeX
#+begin_src emacs-lisp
(use-package auctex
  :ensure t
  :config
  (setq TeX-PDF-mode t))
#+end_src
#+begin_src emacs-lisp
;; (use-package cdlatex
;;   :ensure t
;;   :hook (org-mode . org-cdlatex-mode)
;;   :bind ("<f5>" . cdlatex-math-symbol)
;;   :config
;;   ;; Unbind the backtick key
;;   (define-key cdlatex-mode-map (kbd "`") nil))
#+end_src
** PDF-Tools
#+begin_src emacs-lisp
(use-package pdf-tools
  :ensure t
  :load-path "~/.config/emacs/elpa/pdf-tools-1.1.0")
#+end_src

* Added by LLM Assistant
#+begin_src elisp

(defun my/llm-read-config (file-path)
  "Read and return the content of the specified file."
  (let ((config-file (expand-file-name "~/.config/emacs/config.org")))
    (with-current-buffer
        (insert-file-contents file-path)
      (buffer-string))))

(gptel-make-tool
 :function #'my/llm-read-config
 :name "read_config_file"
 :description "Read file content from given path. Can be used for reading the Emacs configuration files like config.org or init.el."
 :args '((:name "file-path" :type string :description "Path to the file to read")))

#+end_src

*** New Tool: Read Org Heading
This tool allows the LLM to read the content of a specific Org mode heading within a given file.

#+begin_src elisp
(defun my/llm-read-org-heading (file-path heading)
  "Read the content of a specific Org mode HEADING from FILE-PATH.
   Returns the content under the heading as a string."
  (if (file-regular-p file-path)
      (with-temp-buffer
        (insert-file-contents file-path)
        (goto-char (point-min))
        (let ((found-heading-p nil)
              (content-accumulator ()))
          (while (not (eobp))
            (if (org-at-heading-p)
                (progn
                  (if (string= (org-get-heading) heading)
                      (setq found-heading-p t)
                    (if found-heading-p (cl-return)))
                  (forward-line)) ; Move past the heading line itself
              (if found-heading-p
                  (progn
                    (cl-push (buffer-substring-no-properties (line-beginning-position) (line-end-position)) content-accumulator)
                    (forward-line))
                (forward-line)))))
          (if found-heading-p
              (mapconcat #'identity (nreverse content-accumulator) "\n")
            (format "Heading '%s' not found in file '%s'." heading file-path)))
        )
    (format "File not found or is not a regular file: %s" file-path)))

(gptel-make-tool
 :function #'my/llm-read-org-heading
 :name "read_org_heading"
 :description "Read content under a specific Org mode heading in a file."
 :args '(
         (:name "file-path" :type string :description "Path to the Org mode file")
         (:name "heading" :type string :description "The exact heading string (e.g., "* My Section")")
         ))
#+end_src

#+RESULTS:
: my/llm-read-org-heading


* LLM Integration
** New Tool: Read Org Heading
#+begin_src elisp
(defun my/llm-read-config (file-path)
  "Read the content of a file at FILE-PATH."
  (if (file-exists-p file-path)
      (with-temp-buffer
        (insert-file-contents file-path)
        (buffer-string))
    (format "File not found: %s" file-path)))

(defun my/llm-read-org-heading (file-path heading)
  "Read CONTENT under a specific HEADING in an Org mode FILE-PATH."
  (if (file-exists-p file-path)
      (with-temp-buffer
        (insert-file-contents file-path)
        (org-mode)
        (goto-char (point-min))
        (if (re-search-forward (format "^\*+ %s$" (regexp-quote heading)) nil t)
            (progn
              (forward-line 1) ;; Move past the heading line
              (let ((start (point))
                    end)
                (if (re-search-forward "^\*+" nil t)
                    (setq end (match-beginning 0))
                  (setq end (point-max)))
                (buffer-substring-no-properties start end)))
          (format "Heading '%s' not found in %s" heading file-path))
    (format "File not found: %s" file-path)))

(gptel-make-tool
 :function #'my/llm-read-config
 :name "read_config_file"
 :description "Read a file content"
 :args '((:name "file-path" :type string :description "The full path to the file")))

(gptel-make-tool
 :function #'my/llm-read-org-heading
 :name "read_org_heading"
 :description "Read content under a specific Org mode heading in a file."
 :args '((:name "file-path" :type string :description "The full path to the Org mode file")
         (:name "heading" :type string :description "The exact heading string (e.g., \"* My Heading\").")))
#+end_src

#+end_src
